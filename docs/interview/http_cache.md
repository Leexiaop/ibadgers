---
title: http缓存是什么
group: HTTP
toc: content
---

http 缓存就是在浏览器从服务端请求的资源，通过缓存规则保存在浏览器本地，二次请求
的时候不再从服务端获取。而是直接从本地获取缓存资源，降低了 服务器压力，提升了加
载速度。因为浏览器和服务器之间是应答模式，即浏览器发起 http 请求--服务器响应请求
。浏览器第一次向服务器发起请求，拿到请求结果后，会根据相应报文中的响应头的缓存标
识，决定是否要缓存结果，如果需要，则将请求结果和表示存入浏览器缓存中。简单的流程
：

![http缓存流程](https://leexiaop.github.io/static/ibadgers/interview/http_cache_1.png)

- 浏览器每次发起请求，都会从浏览器缓存中查找该请求结果以及缓存标识。
- 浏览器每次拿到返回的请求结果都会将结果和缓存标识存入到浏览器缓存中。

通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP
Header 来实现的。当存在缓存时，客户端第一次向服务器请求数据时，客户端会缓存到内
存或者硬盘当中，当第二次获取相同的资源，强缓存和协商缓存的应对方式有所不同。

`强缓存：`当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接
从 内存/硬盘 中读取.

`协商缓存：`当客户端第二次向服务器请求相同的资源时，先向服务器发送请求"询问"该请
求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存/
硬盘中读取.

## 强缓存

强缓存就是向浏览器缓存查找请求结果，并根据该结果的缓存规则来决定是否使用该缓存结
果的过程.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的
Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或
from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和
Cache-Control。强缓存有三种情况：

- 不存在该缓存结果和缓存标识，强缓存失效，则直接向服务器发起请求(和首次请求一
  样)
- 存在缓存结果和缓存标识，但是结果已经失效，强缓存失效，则使用协商缓存
- 存在该缓存结果和缓存标识，且该结果没有失效，强缓存生效，直接返回该结果当浏览
  器向服务器发送请求的时候，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和
  请求结果一起返回给浏览器，控制强缓存的字段分别是 Expires 和 Cache-Control，
  其中 Cache-Conctrol 的优先级比 Expires 高。

### Expires

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说
，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。

Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏
览器可以直接从浏览器缓存取数据，而无需再次请求。例如
：Expires:Wed,22Oct201808:41:00GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后
过期，需要再次请求。

Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效
。到了 HTTP/1.1，Expires 已经被 Cache-Control 替代。原因在于 Expires 控制缓存的
原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些
原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效
，那么强制缓存存在的意义就毫无意义。

### Cache-Control

在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当
Cache-Control:max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）
的 5 分钟内再次加载资源，就会命中强缓存。Cache-Control 可以在请求头或者响应头中
设置，并且可以组合使用多种指令，主要取值为：

- `public：`所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被
  任何中间节点缓存，如 Browser <-- proxy1 <-- proxy2 <-- Server，中间的 proxy
  也可以缓存资源，比如下次再请求同一资源 proxy1 直接把自己缓存的东西给 Browser
  而不再向 proxy2 要。
- `private：`所有内容只有客户端可以缓存，Cache-Control 的默认取值。具体来说，
  表示中间节点不允许缓存，对于 Browser <-- proxy1 <-- proxy2 <-- Server，proxy
  会老老实实把 Server 返回的数据发送给 Browser ,自己不缓存任何数据。当下次
  Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。

- `no-cache：`客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不
  使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者
  Last-Modified 字段来控制缓存。注意：no-cache 这个名字有一点误导。设置了
  no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需
  要先确认一下数据是否还跟服务器保持一致。

- `no-store：`所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
- `max-age：`max-age=xxx (xxx is numeric)表示缓存内容将在 xxx 秒后失效
- `s-maxage（单位为s)：`同 max-age 作用一样，只在代理服务器中生效（比如 CDN 缓
  存）。比如当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不
  会进行请求。max-age 用于普通缓存，而 s-maxage 用于代理缓存。s-maxage 的优先
  级高于 max-age。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。
- `max-stale：`能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已
  经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果
  没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确
  认的时间与当前时间的差值）。
- `min-fresh：`能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不
  多于当前的 age 加上 min-fresh 设定的时间之和的响应。

多个指令可以配合使用，达到多个目的，其优先级为：

![强缓存](https://leexiaop.github.io/static/ibadgers/interview/http_cache_2.jpeg)

## 协商缓存

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标
识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回 304 和 Not Modified：

![协商缓存](https://leexiaop.github.io/static/ibadgers/interview/http_cach_3.jpeg)

- 协商缓存失效，返回 200 和请求结果
  ![协商缓存](https://leexiaop.github.io/static/ibadgers/interview/http_cach_4.jpeg)

缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

### Last-Modified 和 If-Modified-Since

- Last-Modified

  - 浏览器在第一次访问资源的情况下，服务器会在返回资源的同时，在 response
    header 中添加 Last-Modified 的 header
  - header 的值是这个资源在服务器上的最后修改时间
  - 浏览器接收后，缓存这个文件和 header

- If-Modified-Since
  - 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是
    浏览器添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值。
  - 服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这
    个资源的最后修改时间对比。 如果没有变化，返回 304 和空的响应体，直接从缓
    存读取。如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间
    ，说明文件有更新，于是返回新的资源文件和 200。

Last-Modified 也存在一些弊端:

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被
  修改，服务端不能命中缓存导致发送相同的资源

- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服
  务端会认为资源还是命中了，不会返回正确的资源

既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决
定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和 If-None-Match 来解决这个问题.

### ETag 和 If-None-Match

直接根据文件内容是否修改来决定缓存策略。Etag 是服务器响应请求时，返回当前资源文
件的一个唯一标识(由服务器生成)，只要资源有变化，Etag 就会重新生成。浏览器在下一
次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的
If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资
源的 ETag 值是否一致，就能很好地判断资源相对客户端而言是否被修改过了。

- 如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 回包形式将新的资源（当
  然也包括了新的 ETag）发给客户端。
- 如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。

Etag 和 Last-Modified 比较：

- 在精确度上，Etag 要优于 Last-Modified。Last-Modified 的时间单位是秒，如果某
  个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，
  但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的
  Last-Modified 也有可能不一致。
- 在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而
  Etag 需要服务器通过算法来计算出一个 hash 值。
- 在优先级上，服务器校验优先考虑 Etag

## 两种缓存策略的执行机制

强制缓存优先于协商缓存进行。

- 若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存
- 若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag /
  If-None-Match)

协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回
200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存.具
体流程：

![http缓存流程](https://leexiaop.github.io/static/ibadgers/interview/http_cache_5.jpeg)

## 缓存的位置

### Service Worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用
Service Worker 的话，必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览
器其他内建的缓存机制不同，它可以让我们自由控制缓存那些文件、如何匹配缓存、如何读
取缓存，并且缓存是持续性的。 Service Worker 实现缓存一般分为三个步骤:

- 注册 Service Worker
- 监听到 install 事件以后就可以缓存需要的文件
- 在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存直接读
  取文件，否则就去请求数据当 Service Worker 没有命中缓存的时候，我们需要调用
  fetch()函数获取数据。也就是说：如果我们没有在 Service Worker 命中缓存的话，
  会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请
  求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

### Memory Cache

Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页
面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取
高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中
的缓存也就被释放. 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？
这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用
，所以能让我们使用的内存必然不多。

当我们访问过页面以后，再次刷新页面，此时很多数据都来自于内存缓存。

内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如 <
linkrel=“prefetch”>）下载的资源。preloader 的相关指令已经是页面优化的常见手段之
一，它可以一边解析 js/css 文件，一边网络请求下一个资源。

注意：内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值
，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他
特征做校验。

### Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比
Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本是
最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直
接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一
旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于
HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。

浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？这个问题很多人观点不一样，不过相对
更合理的观点是：

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

### Push Cache

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使
用。

它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在
Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。

如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。

为了性能上的考虑，大部分的接口都应该选择好缓存策略，也就是我们刚刚介绍的强缓存和
协商缓存策略

## 用户行为对缓存的影响

用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略
。主要有 3 种：

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有
  则发送网络请求。

- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用
  (如果匹配的话)。其次才是 disk cache。

- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有
  Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200
  和最新内容。
